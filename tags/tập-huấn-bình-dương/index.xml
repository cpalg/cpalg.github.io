<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tập huấn bình dương on CP notebook</title>
    <link>https://cpalg.github.io/tags/t%E1%BA%ADp-hu%E1%BA%A5n-b%C3%ACnh-d%C6%B0%C6%A1ng/</link>
    <description>Recent content in Tập huấn bình dương on CP notebook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>v4ngtr</copyright>
    <lastBuildDate>Sun, 11 Oct 2020 03:37:54 +0000</lastBuildDate><atom:link href="https://cpalg.github.io/tags/t%E1%BA%ADp-hu%E1%BA%A5n-b%C3%ACnh-d%C6%B0%C6%A1ng/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Tập huấn bình dương ngày 1</title>
      <link>https://cpalg.github.io/posts/2020-10-11-binh-duong-ngay-1/</link>
      <pubDate>Sun, 11 Oct 2020 03:37:54 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-11-binh-duong-ngay-1/</guid>
      <description>Lockdown  Đề bài: lockdown.pdf. Solution: Để phong tỏa 1 con đường mà số con đường bị tăng khoảng cách li&#39; &amp;gt; li là lớn nhất, ta sẽ ưu tiên phong tỏa các con đường đi qua đỉnh 1. Ta thử phong tỏa các con đường đó, sử dụng Dijkstra để đếm xem có bao nhiêu con đường bị tăng khoảng cách. Code mẫu:  #include &amp;lt;bits/stdc++.h&amp;gt;#define pb push_back #define FOR(i, a, b) for(int i = int(a); i &amp;lt;= int(b); i++) #define FORD(i, a, b) for(int i = int(a); i &amp;gt;= int(b); i--) #define REP(i, r) for(int i = 0; i &amp;lt; r; i++) #define FAST ios_base::sync_with_stdio(0); cin.</description>
    </item>
    
    <item>
      <title>Đề bài tập huấn bình dương</title>
      <link>https://cpalg.github.io/posts/2020-10-11-tap-huan-binh-duong/</link>
      <pubDate>Sun, 11 Oct 2020 03:36:54 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-11-tap-huan-binh-duong/</guid>
      <description> BINH_DUONG_NGAY_1.zip. BINH_DUONG_NGAY_2.zip. BINH_DUONG_NGAY_3.zip.  </description>
    </item>
    
  </channel>
</rss>
