<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Quy hoạch động on CP notebook</title>
    <link>https://cpalg.github.io/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/</link>
    <description>Recent content in Quy hoạch động on CP notebook</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>v4ngtr</copyright>
    <lastBuildDate>Fri, 30 Oct 2020 01:03:22 +0000</lastBuildDate><atom:link href="https://cpalg.github.io/tags/quy-ho%E1%BA%A1ch-%C4%91%E1%BB%99ng/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Chia quà - ntucoder</title>
      <link>https://cpalg.github.io/posts/2020-10-30-divide/</link>
      <pubDate>Fri, 30 Oct 2020 01:03:22 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-30-divide/</guid>
      <description>Link đề bài:  http://ntucoder.net/Problem/Details/4414.  Hướng dẫn:  Gọi f[i][j] là số cách chia các món quà từ 1 tới i món quà, vào j túi. Nếu chia món quà thứ i vào một túi mới thì f[i][j] = f[i-1][j-1] Nếu bỏ món quà đó vào các túi sẵn có f[i][j] = f[i-1][j] * j  Code mẫu: #include &amp;lt;bits/stdc++.h&amp;gt;#define JN Jonasngyn #define pb push_back #define FOR(i, a, b) for(int i = int(a); i &amp;lt;= int(b); i++) #define FORD(i, a, b) for(int i = int(a); i &amp;gt;= int(b); i--) #define REP(i, r) for(int i = 0; i &amp;lt; r; i++) #define FAST ios_base::sync_with_stdio(0); cin.</description>
    </item>
    
    <item>
      <title>Chia kẹo - LQDOJ</title>
      <link>https://cpalg.github.io/posts/2020-10-30-chiakeo/</link>
      <pubDate>Fri, 30 Oct 2020 01:02:22 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-30-chiakeo/</guid>
      <description>Link đề bài:  https://lqdoj.edu.vn/problem/sharecandies/.  Hướng dẫn:  Gọi f[i][j] là số cách chia kẹo cho i người, và đã chia được j viên kẹo.  Code mẫu: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string.h&amp;gt;#define ii pair&amp;lt;int, int&amp;gt; #define fi first #define se second using namespace std; const int MAX = 1e5+6; const int MOD = 1e9+7; int n, k, f[101][MAX], a[MAX]; int main(int argc, char const *argv[]) { ios_base::sync_with_stdio(0); cin.tie(0); cout.</description>
    </item>
    
    <item>
      <title>SGAME8 - LQDOJ</title>
      <link>https://cpalg.github.io/posts/2020-10-30-sgame8/</link>
      <pubDate>Fri, 30 Oct 2020 01:02:22 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-30-sgame8/</guid>
      <description>Link đề bài:  https://lqdoj.edu.vn/problem/sgame8/.  Hướng dẫn: Code mẫu: #include &amp;lt;bits/stdc++.h&amp;gt;#define ii pair&amp;lt;int, int&amp;gt; #define fi first #define se second using namespace std; typedef vector&amp;lt;int&amp;gt; bigNum; const int MAX = -1; const int BASE = 1000000000; bigNum Fix(bigNum a){ a.push_back(0); for(int i=0; i&amp;lt;(int)a.size(); i++){ a[i+1]+= a[i]/BASE; a[i]%= BASE; while (a[i] &amp;lt; 0) a[i]+= BASE, a[i+1]--; } while (a.size()&amp;gt;1 &amp;amp;&amp;amp; a.back()==0) a.pop_back(); return a; } void Print(bigNum a){ printf(&amp;#34;%d&amp;#34;, a.back()); for(int i=a.</description>
    </item>
    
    <item>
      <title>Bội số chung nhỏ nhất - VNOI</title>
      <link>https://cpalg.github.io/posts/2020-10-29-ctnown/</link>
      <pubDate>Thu, 29 Oct 2020 07:02:22 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-29-ctnown/</guid>
      <description>Link đề bài:  http://vnoi.info/problems/FINDNUM/.  Hướng dẫn: Code mẫu: #include &amp;lt;iostream&amp;gt;#include &amp;lt;algorithm&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;string.h&amp;gt;#define int unsigned long long #define ii pair&amp;lt;int, int&amp;gt; #define fi first #define se second using namespace std; const int MAX = 355; int n, Prime[MAX], f[MAX][MAX], r[MAX], T; std::vector&amp;lt;int&amp;gt; pr; void Eratos(){ memset(Prime, 1, sizeof Prime); Prime[0] = Prime[1] = 0; for(int i=2; i*i &amp;lt; MAX; i++){ if (Prime[i]) for(int j=i*2; j&amp;lt;MAX; j+=i){ Prime[j] = false; } } pr.</description>
    </item>
    
    <item>
      <title>Tìm số - VNOI</title>
      <link>https://cpalg.github.io/posts/2020-10-29-findnum/</link>
      <pubDate>Thu, 29 Oct 2020 06:02:22 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-29-findnum/</guid>
      <description>Link đề bài:  http://vnoi.info/problems/FINDNUM/.  Hướng dẫn:  Gọi f[i][j] là số nhỏ nhất có i ước, tạo từ j số nguyên tố đầu tiên, Số có 1000 ước ta chỉ xét khoảng 10 số nguyên tố đầu tiên là đủ. Ta có thể phân tích số tự nhiên x thành dãy x1^k1 * x2^k2 * ... *xn^kn. Với mỗi xi có (ki+1) cách chọn. Từ nhận xét trên, ta có công thức qhđ: f[i][j] = min(f[i/(k+1)][j-1] * prime[j]^k, f[i][j-1]).</description>
    </item>
    
    <item>
      <title>Pictures with Kittens - Codeforces</title>
      <link>https://cpalg.github.io/posts/2020-10-06-cf1077f2/</link>
      <pubDate>Tue, 06 Oct 2020 03:36:54 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-06-cf1077f2/</guid>
      <description>Link đề bài:  https://codeforces.com/contest/1077/problem/F2.  Hướng dẫn: Code mẫu: #include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#define pb push_back #define FOR(i, a, b) for(int i = int(a); i &amp;lt;= int(b); i++) #define FORD(i, a, b) for(int i = int(a); i &amp;gt;= int(b); i--) #define REP(i, r) for(int i = 0; i &amp;lt; r; i++) #define FAST ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define READFILE freopen(&amp;#34;input.txt&amp;#34;, &amp;#34;r&amp;#34;, stdin) #define WRITEFILE freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout); #define ll long long #define ii pair&amp;lt;int, int&amp;gt; #define fi first #define se second using namespace std; const int MAX= 5005; ll n, k, x, a[MAX], f[MAX][MAX]; deque&amp;lt;int&amp;gt; pq; void Insert(int col, int row){ while (pq.</description>
    </item>
    
    <item>
      <title>Boredom - Codeforces</title>
      <link>https://cpalg.github.io/posts/2020-10-06-cf445a/</link>
      <pubDate>Tue, 06 Oct 2020 02:36:54 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-06-cf445a/</guid>
      <description>Link đề bài:  https://codeforces.com/contest/455/problem/A.  Hướng dẫn: Code mẫu: #include &amp;lt;bits/stdc++.h&amp;gt;#define pb push_back #define FOR(i, a, b) for(int i = int(a); i &amp;lt;= int(b); i++) #define FORD(i, a, b) for(int i = int(a); i &amp;gt;= int(b); i--) #define REP(i, r) for(int i = 0; i &amp;lt; r; i++) #define FAST ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define READFILE freopen(&amp;#34;input.txt&amp;#34;, &amp;#34;r&amp;#34;, stdin) #define WRITEFILE freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout); #define ll long long #define ii pair&amp;lt;int, int&amp;gt; #define fi first #define se second using namespace std; const int MAX= 1e5+6; ll n, a[MAX], Mx, cnt[MAX], f[MAX], pi; int main() { #ifndef ONLINE_JUDGE  READFILE; #endif  FAST; cin &amp;gt;&amp;gt; n; for(int i=1; i&amp;lt;=n; i++) cin &amp;gt;&amp;gt; a[i]; for(int i=1; i&amp;lt;=n; i++){ cnt[a[i]]++; Mx = max(Mx, a[i]); } for(int i=1; i&amp;lt;=Mx; i++){ f[i] = max(f[i-1], f[pi] + cnt[i]*i); if (f[i-1] &amp;gt; f[pi]) pi = i-1; } cout&amp;lt;&amp;lt; f[Mx]; return 0; } Tham khảo:  https://robert1003.</description>
    </item>
    
    <item>
      <title>Cats Transport - Codeforces</title>
      <link>https://cpalg.github.io/posts/2020-10-05-cf185b/</link>
      <pubDate>Mon, 05 Oct 2020 02:36:54 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-05-cf185b/</guid>
      <description>Link đề bài:  https://codeforces.com/contest/311/problem/B.  Hướng dẫn: Code mẫu: #include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;algorithm&amp;gt;#define ll long long #define ii pair&amp;lt;ll, ll&amp;gt; #define fi first #define se second using namespace std; const int MAX = 1e5+6; std::vector&amp;lt;ll&amp;gt; A; std::vector&amp;lt;ll&amp;gt; B; int n, m, k, pt; ll a[MAX], c[MAX], f[MAX][123], s[MAX]; ii b[MAX]; bool Bad(int l1, int l2, int l3){ return (B[l3] - B[l1]) * (A[l1] - A[l2]) &amp;lt; (B[l2] - B[l1]) * (A[l1] - A[l3]); } void Add(ll a, ll b){ A.</description>
    </item>
    
    <item>
      <title>Bear and Bowling 4 - Codeforces</title>
      <link>https://cpalg.github.io/posts/2020-10-04-cf660f/</link>
      <pubDate>Sun, 04 Oct 2020 02:36:54 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-04-cf660f/</guid>
      <description>Link đề bài:  https://codeforces.com/problemset/problem/660/F.  Hướng dẫn:  Gọi:  \(dp_i\) là giá trị lớn nhất tạo được khi ta chọn dãy kết thúc tại vị trí \(i\). \(s_i\) là \(\sum\limits_{x = 1}^i {a_x * x}\). \(p_i\) là \(\sum\limits_{x = 1}^i {a_x}\).   Ta có công thức quy hoạch động: \(dp_i = s_i - j * p_i + s_j - j * p_j\) Hàm có dạng \(a*x+b\) nên dùng qhd bao lồi.</description>
    </item>
    
    <item>
      <title>Product Sum - Codeforces</title>
      <link>https://cpalg.github.io/posts/2020-10-04-cf631e/</link>
      <pubDate>Sun, 04 Oct 2020 02:36:54 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-04-cf631e/</guid>
      <description>Link đề bài:  https://codeforces.com/problemset/problem/631/E.  Hướng dẫn:  Ta xét 2 trường hợp:   TH1: Di chuyển một khối từ vị trí \(i\) tới vị trí \(j\) \((i &amp;lt; j)\).
 Tất cả các khối ở vị trí thứ \(k\) \((i+1 &amp;lt;= k &amp;lt;= j)\) sẽ bị giảm đi \(a_k\). Giá trị của khối \(i\) sẽ tăng từ \(i * a_i\) lên thành \(j * a_j\). Ta có công thức qhđ: \(dp_j = c - \sum\limits_{k = i+1}^j {a_k} + j * a_i - i * a_i\).</description>
    </item>
    
    <item>
      <title>The Fair Nut and Rectangles - Codeforces</title>
      <link>https://cpalg.github.io/posts/2020-10-03-cf1083e/</link>
      <pubDate>Sat, 03 Oct 2020 02:36:54 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-03-cf1083e/</guid>
      <description>Link đề bài:  https://codeforces.com/contest/1083/problem/E/.  Hướng dẫn:  Đầu tiên ta sắp xếp các hình chữ nhật theo chiều dài tăng dần, mà đề nói không có hình chữ nhật nào chứa hình khác \(-&amp;gt;\) Chiều rộng các hình chữ nhật sau khi sắp xếp sẽ giảm dần. Gọi f[i] là cách chọn tối ưu để chọn một số hình chữ nhật từ 1 tới i:  Ta có: f[i] = max(f[j] + h[i]*w[i] - h[i]*w[j] - a[i]) \((0 &amp;lt;j &amp;lt; i)\) (hcn thứ \(j\) là hình cuối cùng ta chọn trước khi chọn hcn thứ \(i\)).</description>
    </item>
    
    <item>
      <title>Land Acquisition - VNOI</title>
      <link>https://cpalg.github.io/posts/2020-10-03-acquire/</link>
      <pubDate>Sat, 03 Oct 2020 02:35:54 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-03-acquire/</guid>
      <description>Link đề bài:  https://www.spoj.com/problems/ACQUIRE/.  Hướng dẫn:  Ta có một nhận xét rằng: Giả sử tồn tại hai hình chữ nhật với kích thước \((a,b)\) và \((x,y)\). nếu \(a&amp;lt;=x\) và \(b&amp;lt;=y \) thì ta có thể bỏ luôn hình chữ nhật kích thước \((a,b)\) bởi vì chỉ cần gộp hình chữ nhật kích thước \((a,b)\) vào hình chữ nhật kích thước \((x,y)\) thì sẽ không mất phí, do đó ta loại bỏ tất cả các hình chữ nhật thừa.</description>
    </item>
    
    <item>
      <title>Quy hoạch động bao lồi - Lý thuyết</title>
      <link>https://cpalg.github.io/posts/2020-10-02-qhd-bao-loi/</link>
      <pubDate>Fri, 02 Oct 2020 02:35:54 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-10-02-qhd-bao-loi/</guid>
      <description>Kĩ thuật qhd bao lồi là kĩ thuật (hoặc là cấu trúc dữ liệu) dùng để xác định hiệu quả, có tiền xử lý, cực trị của một tập các hàm tuyến tính tại một giá trị của biến độc lập. Mặc dù tên gọi giống nhưng kĩ thuật này lại khá khác biệt so với thuật toán bao lồi của hình học tính toán. Ngoài ra có một kĩ thuật liên quan đến kĩ thuật bao lồi là IT đoạn thẳng.</description>
    </item>
    
    <item>
      <title>Trò chơi với những viên đá - LQDOJ.</title>
      <link>https://cpalg.github.io/posts/2020-09-27-stones/</link>
      <pubDate>Sun, 27 Sep 2020 06:58:22 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-09-27-stones/</guid>
      <description>Link đề bài:  http://lqdoj.edu.vn/problem/stones.  Hướng dẫn: Code mẫu: #include &amp;lt;bits/stdc++.h&amp;gt;#define pb push_back #define FOR(i, a, b) for(int i = int(a); i &amp;lt;= int(b); i++) #define FORD(i, a, b) for(int i = int(a); i &amp;gt;= int(b); i--) #define REP(i, r) for(int i = 0; i &amp;lt; r; i++) #define FAST ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define READFILE freopen(&amp;#34;input.txt&amp;#34;, &amp;#34;r&amp;#34;, stdin) #define WRITEFILE freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout); #define ll long long #define ii pair&amp;lt;int, int&amp;gt; #define fi first #define se second #define ENDL &amp;#34;\n&amp;#34; using namespace std; const int MAX= 111; const int MAXK = 1e5+6; int a[MAX], n, k; int f[MAXK][2]; int DP(int len, bool player){ if (len &amp;lt; 0) return 0; if (f[len][player]!</description>
    </item>
    
    <item>
      <title>Phép toán với ngăn xếp hai đầu - LQDOJ.</title>
      <link>https://cpalg.github.io/posts/2020-09-27-deque/</link>
      <pubDate>Sun, 27 Sep 2020 06:45:22 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-09-27-deque/</guid>
      <description>Link đề bài:  http://lqdoj.edu.vn/problem/deque.  Hướng dẫn: Code mẫu: #include &amp;lt;bits/stdc++.h&amp;gt;#define pb push_back #define FOR(i, a, b) for(int i = int(a); i &amp;lt;= int(b); i++) #define FORD(i, a, b) for(int i = int(a); i &amp;gt;= int(b); i--) #define REP(i, r) for(int i = 0; i &amp;lt; r; i++) #define FAST ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define READFILE freopen(&amp;#34;input.txt&amp;#34;, &amp;#34;r&amp;#34;, stdin) #define WRITEFILE freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout); #define ll long long #define ii pair&amp;lt;int, int&amp;gt; #define fi first #define se second #define ENDL &amp;#34;\n&amp;#34; using namespace std; const int MAX= 3003; long long a[MAX], n, f[MAX][MAX]; long long DP(int l, int r){ if (l &amp;gt; r) return 0; if (f[l][r] !</description>
    </item>
    
    <item>
      <title>SGAME6 - LQDOJ.</title>
      <link>https://cpalg.github.io/posts/2020-09-27-sgame6/</link>
      <pubDate>Sun, 27 Sep 2020 06:45:22 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-09-27-sgame6/</guid>
      <description>Link đề bài:  http://lqdoj.edu.vn/problem/sgame6.  Hướng dẫn: Code mẫu: #include &amp;lt;bits/stdc++.h&amp;gt;#define pb push_back #define FOR(i, a, b) for(int i = int(a); i &amp;lt;= int(b); i++) #define FORD(i, a, b) for(int i = int(a); i &amp;gt;= int(b); i--) #define REP(i, r) for(int i = 0; i &amp;lt; r; i++) #define FAST ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define READFILE freopen(&amp;#34;input.txt&amp;#34;, &amp;#34;r&amp;#34;, stdin) #define WRITEFILE freopen(&amp;#34;output.txt&amp;#34;, &amp;#34;w&amp;#34;, stdout); #define ll long long #define ii pair&amp;lt;int, int&amp;gt; #define fi first #define se second #define ENDL &amp;#34;\n&amp;#34; using namespace std; const int MAX= 311; int f[MAX][MAX], a[MAX], n, sum; int DP(int l, int r){ if (r-l+1 &amp;gt;= n) return 0; if (f[l][r]!</description>
    </item>
    
    <item>
      <title>SGAME7 - LQDOJ.</title>
      <link>https://cpalg.github.io/posts/2020-09-25-sgame7/</link>
      <pubDate>Thu, 24 Sep 2020 08:58:22 +0000</pubDate>
      
      <guid>https://cpalg.github.io/posts/2020-09-25-sgame7/</guid>
      <description>Link đề bài:  http://lqdoj.edu.vn/problem/sgame7.  Hướng dẫn: Có 2 vấn đề cân sử lý:
1. Đếm số các số có tổng bằng k trong đoạn từ A tới B  Ta sử dụng phương pháp quy hoạch động chữ số để giải quyết bài toán này (Xài top down cho nhanh):  Gọi DP(S, id, sum, prefixMatch) là số cách tạo ra tổng sum từ id chữ số đầu nhỏ hơn hoặc bằng số S(Dạng string), và prefixMatch = true nếu tiền tố của số đang xét tới vị trí id khớp với tiền tố của S.</description>
    </item>
    
  </channel>
</rss>
